<_TerroirAvatar cullFace="off" transparent="true"><uniform name="SplotchCellSize" type="float" value="0.3"/><uniform name="SplotchWaveNr" type="int" value="8"/><uniform name="Time" type="int" value="0"/><uniform name="WaterScale" type="vec3" value="0.50 0.5 0.3"/><uniform name="WaterColor" type="vec4" value="1 1 1 1"/><uniform name="WaveSpeed" type="vec3" value="0.2 0.1 0.2"/><uniform name="WaveSpeed2" type="vec3" value="-0.1 0.2 -0.2"/><uniform name="WaveScale" type="vec3" value="2 1.5 0.2"/><uniform name="diffuseMap" type="sampler2D" value="0"/><uniform name="normalMap" type="sampler2D" value="0"/><uniform name="waterCubeMap" type="sampler2D" value="2"/><uniform name="starryCubeMap" type="sampler2D" value="3"/><uniform name="forestCubeMap" type="sampler2D" value="4"/><uniform name="FresExp" type="float" value="0.5"/><uniform name="fps" type="float" value="0.4"/><uniform name="Bumpiness" type="float" value="0.1"/><uniform name="Transparency" type="float" value="0.2"/><uniform name="KrMin" type="float" value="0.1"/><uniform name="Kr" type="float" value="1.0"/><attribute name="aBinormal" type="binormal" value="6"/><attribute name="aTangent" type="tangent" value="7"/><vertexProgram>varying vec3 normal, lightDir, eyeVec;
    varying vec3 Binormal;
    varying vec3 Tangent;
    varying vec2 Texcoord;
    varying vec2 Texcoord2;
    varying vec2 Texcoord3;

    attribute vec3 aBinormal;
    attribute vec3 aTangent;

    uniform vec3 WaveSpeed;
    uniform vec3 WaveSpeed2;
    uniform vec3  WaterScale;
    uniform vec3 WaveScale;
    
    uniform int Time;
    uniform float fps;

    void main( void )
    {
        float time = (float(Time)/1000.0)*fps;
        normal   = gl_NormalMatrix * gl_Normal;
        Binormal = gl_NormalMatrix * aBinormal;
        Tangent  = gl_NormalMatrix * aTangent; 
        Texcoord.x = gl_MultiTexCoord0.x ;
        Texcoord.y = gl_MultiTexCoord0.y ;
        Texcoord2.x = gl_MultiTexCoord0.x *WaterScale.x +time*WaveSpeed.x*WaveScale.x;
        Texcoord2.y = gl_MultiTexCoord0.y *WaterScale.y +time*WaveSpeed.y*WaveScale.y;
        Texcoord3.x = gl_MultiTexCoord0.x *WaterScale.x +time*WaveSpeed2.x*WaveScale.x;
        Texcoord3.y = gl_MultiTexCoord0.y *WaterScale.y +time*WaveSpeed2.y*WaveScale.y;
     
     	vec3 vVertex = vec3(gl_ModelViewMatrix * gl_Vertex);

     	lightDir = vec3(gl_LightSource[0].position.xyz - vVertex);
     	eyeVec = -vVertex;
     	
     
	gl_Position = ftransform();	
gl_ClipVertex = gl_ModelViewMatrix*gl_Vertex;
    }
  </vertexProgram><fragmentProgram>varying vec3 normal, lightDir, eyeVec;
    varying vec3 Binormal;
    varying vec3 Tangent;
    varying vec2 Texcoord;
    varying vec2 Texcoord2;
    varying vec2 Texcoord3;
   
   
    uniform sampler2D diffuseMap;
    uniform sampler2D normalMap;
    uniform sampler2D waterCubeMap;
    uniform sampler2D starryCubeMap;
    uniform sampler2D forestCubeMap;

    uniform int Time;
    uniform vec4  WaterColor;
   
    uniform float Bumpiness;
    uniform float Transparency;
    uniform float KrMin;
    uniform float Kr;
    uniform float FresExp;

    uniform float SplotchCellSize;
    uniform int SplotchWaveNr;
   
    void main( void )
    {
         vec3 position = gl_FrontMaterial.diffuse.rgb;
         int gridSize = 3;
         int totalSplotches = gridSize * gridSize;
         float t = mod(float(Time), float(totalSplotches)*500.0); // loop over all splotches
         int splotchToShow = int(t/500.0);

         // Sample the reflection image/cube map for a seed
        float imageSeed = 0.5; //textureCube(waterCubeMap, vec3(1.0, 0.0, 0.0)).r * 100.0;

        // For each splotch, compute its "random" order index
        int splotchX = int(floor(Texcoord.x * float(gridSize)));
        int splotchY = int(floor(Texcoord.y * float(gridSize)));
        int splotchIdx = splotchY * gridSize + splotchX;

        // Hash function for permutation (deterministic, based on imageSeed and splotchIdx)
        int permutedOrder = int(mod(float(splotchIdx) * 13.37 + imageSeed * 7.91 +sin(float(splotchIdx) * 2.13 + imageSeed * 0.77) * 100.0, float(totalSplotches)));

        // Reveal splotches in permuted order
        vec2 cellSize = vec2(1.0 / float(gridSize));
        vec2 cellCenter = (vec2(splotchX, splotchY) + 0.5) * cellSize;

        // Distance from fragment to center of its splotch
        float dist = distance(Texcoord, cellCenter);

        // Wavy radius: base radius plus sine modulation
        float angle = atan(Texcoord.y - cellCenter.y, Texcoord.x - cellCenter.x);
        float baseRadius = SplotchCellSize * cellSize.x;
        float wave = 0.05 * cellSize.x * sin(float(SplotchWaveNr) * angle + 0.005);
        float splotchRadius = baseRadius + wave;
        float show = (permutedOrder &lt; splotchToShow &amp;&amp; dist &lt; splotchRadius) ? 1.0 : 0.0;

      vec4 final_color =
      	(gl_FrontLightModelProduct.sceneColor * gl_FrontMaterial.ambient) +
      	(gl_LightSource[0].ambient * gl_FrontMaterial.ambient);

      vec3 bumpmap = 2.0 * Bumpiness * texture2D( normalMap, Texcoord2 ).xyz - vec3(0.5,0.5,0.5);
      bumpmap = mix(-bumpmap,2.0 * Bumpiness * texture2D( normalMap, Texcoord3 ).xyz - vec3(0.5,0.5,0.5),0.5);
	  
      vec3 N = normalize(normal);
      vec3 Tn = normalize(Tangent);
      vec3 Bn = normalize(Binormal);
      N += (bumpmap.x * Tn + bumpmap.y * Bn);
      N = normalize(N);
      
      vec3 eyeVecN = normalize(eyeVec);
      	
      vec3 L = normalize(lightDir);

      vec3 reflVec   = reflect(-eyeVecN, N);
      vec4 reflColor;
      if (position.z &gt; -23.0  &amp;&amp; position.z &lt; -9.0 ) {
          //reflColor = textureCube(starryCubeMap, reflVec);
          gl_FragColor = texture2D(starryCubeMap, Texcoord); //vec4(1.0, 0.0, 0.0, 1.0);
          gl_FragColor.a = 1.0;
      } else if (position.z &gt; -7.0 &amp;&amp; position.z &lt; 6.5) {
          //reflColor = textureCube(waterCubeMap, reflVec);
         gl_FragColor = texture2D(waterCubeMap, Texcoord); //vec4(0.0, 0.0, 1.0, 1.0);
      } else if (position.z &gt; 9.5 &amp;&amp; position.z &lt; 23.0) {
          //reflColor = textureCube(forestCubeMap, reflVec);
          gl_FragColor = texture2D(forestCubeMap, Texcoord); // vec4(0.0, 1.0, 0.0, 1.0);
      } else {
           gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
      }
      return;
      float lambertTerm = abs(dot(N,L));
      if(lambertTerm &gt; 0.0)
      {
      
      	final_color += gl_LightSource[0].diffuse *
      	               WaterColor * lambertTerm*texture2D( diffuseMap, Texcoord);
        float vdn = dot(eyeVecN,N);
	float fres = KrMin + (Kr-KrMin) * pow(1.0-abs(vdn),FresExp);
	final_color = mix(final_color  ,reflColor,fres);
      //	final_color =	             reflColor;
      	vec3 E = normalize(eyeVecN);
      	vec3 R = reflect(-L, N);
      	float specular = pow( max(dot(R, E), 0.0), 
      		                 gl_FrontMaterial.shininess );
      	final_color += gl_LightSource[0].specular *
      	               gl_FrontMaterial.specular * 
      				   specular;	
        final_color.a = max(WaterColor.a,fres)- Transparency;
        final_color.rgb+=texture2D( diffuseMap, Texcoord).rgb;
        final_color.rgb = mix(vec3(0.0), final_color.rgb, show);
        final_color.a *= show;
      	}
	gl_FragColor = final_color;	
          
    }
  </fragmentProgram></_TerroirAvatar>