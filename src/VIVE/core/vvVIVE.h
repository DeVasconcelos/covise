/* This file is part of COVISE.

   You can use it under the terms of the GNU Lesser General Public License
   version 2.1 or later, see lgpl-2.1.txt.

 * License: LGPL 2+ */

#pragma once


#include <vsg/core/Visitor.h>
#include <vsg/core/Inherit.h>
#include <util/common.h>
#include <../../OpenCOVER/OpenVRUI/coInteractionManager.h>

#include <vrb/client/VrbCredentials.h>

#include <memory>
#ifdef HAS_MPI
#include <mpi.h>
#ifdef __APPLE__
typedef void pthread_barrier_t;
#else
#include <pthread.h>
#endif
#endif

namespace covise
{
class Message;
}
namespace vrb{
class VRBClient;
}
namespace vive
{
namespace ui
{
class Action;
class Button;
class Group;
}

class vvHud;
class buttonSpecCell;
class vvPlugin;
class vvTabletUI;
class vvTUITabFolder;
class vvTui;
class vvVIVE;

/// CloseHandler event handler used to respond to close events generated by a Window.
class EventHandler : public vsg::Inherit<vsg::Visitor, EventHandler>
{
public:
    enum
    {
        KEYUP=1,
        KEYDOWN=2,
        lastEventType
    };
    explicit EventHandler(vvVIVE* vive_in) :
        _vive(vive_in) {}


    void apply(vsg::KeyPressEvent& keyPress) override;
    void apply(vsg::KeyReleaseEvent& keyRelease) override;
    void apply(vsg::FocusInEvent& focusIn) override;
    void apply(vsg::FocusOutEvent& focusOut) override;
    void apply(vsg::ButtonPressEvent& buttonPress) override;
    void apply(vsg::ButtonReleaseEvent& buttonRelease) override;
    void apply(vsg::MoveEvent& moveEvent) override;
    void apply(vsg::ScrollWheelEvent& scrollWheel) override;
    void apply(vsg::CloseWindowEvent&) override;
    void apply(vsg::TerminateEvent&) override;

protected:
    vvVIVE* _vive;
};

class VVCORE_EXPORT vvVIVE
{
private:
    vrui::coInteractionManager interactionManager;
    bool exitFlag;
    int frameNum;
    std::unique_ptr<vrb::VrbCredentials> m_vrbCredentials;
    static vvVIVE *s_instance;
    double fl_time, old_fl_time;
    double sum_time;
    bool printFPS;
    bool ignoreMouseEvents;

    void waitForWindowID();

    bool m_loadVistlePlugin = false;
    std::string m_vistlePlugin;
    vvPlugin *m_visPlugin;
    bool m_forceMpi;

    ui::Group *m_quitGroup=nullptr;
    ui::Action *m_quit=nullptr;
    ui::Button *m_clusterStats=nullptr;

    

public:

vsg::ref_ptr<vsg::Node> scenegraph;
    vvVIVE();
#ifdef HAS_MPI
    vvVIVE(const MPI_Comm *comm, pthread_barrier_t *shmBarrier);
#endif
#ifdef WIN32
    vvVIVE(HWND parentWindow);
#else
    vvVIVE(int parentWindow);
#endif
    bool run();
    bool init();
    bool initDone();
    ~vvVIVE();
    void loop();
    bool frame();
    void doneRendering();
    void setExitFlag(bool flag);
    int getExitFlag()
    {
        return exitFlag;
    }
    static vvVIVE *instance();
    void handleEvents(int type, int state, int code);
    vvHud *hud;
    double beginAppTraversal;
    double endAppTraversal;
    double lastUpdateTime = -1.0, lastFrameTime = -1.0;
    std::deque<double> frameDurations;
    void setIgnoreMouseEvents(bool ign)
    {
        ignoreMouseEvents = ign;
    }
#ifdef WIN32
    HWND parentWindow;
#else
    // should be Window from <X11/Xlib.h>
    int parentWindow;
#endif

    void requestQuit();
    vvPlugin *visPlugin() const;
    bool useVistle() const;

    size_t numTuis() const;
    vvTabletUI *tui(size_t idx) const;
    vvTUITabFolder *tuiTab(size_t idx) const;
    vvTui *vrTui(size_t idx) const;
    void pushTui(vvTabletUI *tui, vvTui *vrTui);
    void popTui();
    

    //! register filedescriptor fd for watching so that scene will be re-rendererd when it is ready
    bool watchFileDescriptor(int fd);
    //! remove fd from filedescriptors to watch
    bool unwatchFileDescriptor(int fd);
    const vrb::VRBClient *vrbc() const;
    vrb::VRBClient *vrbc();
    void startVrbc();
    void restartVrbc();
    bool isVRBconnected() const;
    std::vector<std::unique_ptr<vvTabletUI>> tabletUIs;

private:
#ifdef HAS_MPI
    MPI_Comm m_comm;
    pthread_barrier_t *m_shmBarrier = nullptr;
#endif
    bool m_renderNext;
    bool m_initialized = false;
    std::vector<std::unique_ptr<vvTui>> tabletVrTuis;
    std::unique_ptr<vrb::VRBClient> m_vrbc;
	std::string m_startSession;

    std::set<int> m_watchedFds;
};
}

EVSG_type_name(vive::EventHandler);
